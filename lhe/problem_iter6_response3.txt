```python
def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    n = len(demands)
    vehicle_capacity = max(demands)
    normalized_demands = demands / vehicle_capacity

    epsilon = 1e-10
    edge_utility = 1 / (distance_matrix + epsilon)
    edge_utility = np.clip(edge_utility, 0, 1e10)

    heuristics_matrix = np.zeros_like(distance_matrix)

    # Calculate the utility considering the inverse distance and normalized demands
    heuristics_matrix = edge_utility * normalized_demands[:, None] * normalized_demands[None, :]

    # Penalize self-loops
    np.fill_diagonal(heuristics_matrix, -np.inf)

    # Demand satisfaction factor, 1 when no demand, 0 when fully satisfied
    demand_satisfaction = 1 - np.dot(normalized_demands[:, np.newaxis], normalized_demands[np.newaxis, :])
    heuristics_matrix *= demand_satisfaction

    # Penalize edges that would cause overcapacity
    overcapacity_mask = (normalized_demands[:, None] + normalized_demands[None, :]) > 1
    heuristics_matrix[overcapacity_mask] = -np.inf

    # Additional penalty for connections to the depot based on unsatisfied demand
    unsatisfied_demand_penalty = -normalized_demands[1:] * (1 - demand_satisfaction[1:, 0])
    heuristics_matrix[0, 1:] += unsatisfied_demand_penalty
    heuristics_matrix[1:, 0] += unsatisfied_demand_penalty[::-1]

    return heuristics_matrix
```
