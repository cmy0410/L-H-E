```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    capacity = np.sum(demands)
    n_nodes = len(demands)
    
    # Mask the diagonal to prevent self-loops and set to -inf
    np.fill_diagonal(distance_matrix, -np.inf)
    
    # Calculate demand differences matrix and scale it
    demand_diff = np.subtract.outer(demands, demands)
    np.fill_diagonal(demand_diff, -np.inf)
    demand_diff[demand_diff == 0] = -np.inf
    scaled_demand_diff = demand_diff / (capacity + 1e-10)
    
    # Calculate inverse distance to prioritize shorter routes
    epsilon = 1e-10
    inverse_distance = 1.0 / (distance_matrix + epsilon)
    
    # Combine inverse distance and scaled demand difference for heuristic values
    heuristic_values = inverse_distance + scaled_demand_diff
    
    # Apply capacity constraints efficiently
    accumulated_demands = np.cumsum(demands)
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if accumulated_demands[i-1] + demands[j] > capacity:
                heuristic_values[i, j] = -np.inf
    
    # Set heuristic values for returning to the depot to -inf, except for the depot itself
    heuristic_values[:, 0] = -np.inf
    heuristic_values[0, :] = -np.inf

    return heuristic_values
```
