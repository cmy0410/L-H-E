```python
import torch

def heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:
    """
    Heuristics function for CVRP that returns a matrix with positive values for promising edges
    and negative values for undesirable ones. Prioritizes edges that lead to nodes with lower
    demands and fewer vehicles, and penalizes edges that would exceed vehicle capacities.
    
    Args:
    - distance_matrix (torch.Tensor): Distance matrix of shape (n, n) where n is the number of nodes.
    - demands (torch.Tensor): Vector of customer demands of shape (n) where the depot node is indexed by 0.
    
    Returns:
    - torch.Tensor: Heuristic values of shape (n, n).
    """
    # Ensure that demands are normalized by the total vehicle capacity
    total_capacity = demands[0]
    demands = demands / total_capacity
    
    # Calculate the number of vehicles required for each customer node
    num_vehicles = demands.round().int()
    
    # Create a matrix that indicates if the edge would cause capacity overflow
    capacity_overflow = torch.zeros_like(distance_matrix, dtype=torch.bool)
    for i in range(1, len(demands)):
        capacity_overflow[i, :i] = demands[i] > distance_matrix[i, :i]
    
    # Create a matrix that indicates if the edge leads to a node with lower demand
    lower_demand_penalty = torch.zeros_like(distance_matrix)
    for i in range(1, len(demands)):
        for j in range(i):
            if demands[j] > demands[i]:
                lower_demand_penalty[i, j] = -(demands[j] - demands[i])
    
    # Create a matrix that indicates if the edge leads to a node with more vehicles
    fewer_vehicles_bonus = torch.zeros_like(distance_matrix)
    for i in range(1, len(demands)):
        for j in range(i):
            if num_vehicles[j] > num_vehicles[i]:
                fewer_vehicles_bonus[i, j] = num_vehicles[i] - num_vehicles[j]
    
    # Combine the above matrices to get the final heuristic matrix
    heuristic_matrix = distance_matrix + lower_demand_penalty + fewer_vehicles_bonus
    
    # Apply a mask to ensure that no negative values are included (excluding the diagonal)
    heuristic_matrix = torch.where(capacity_overflow, torch.tensor(-1e9, dtype=torch.float32), heuristic_matrix)
    
    return heuristic_matrix
```
