```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    capacity = np.sum(demands)
    n_nodes = len(demands)

    # Mask the diagonal as we cannot have self-loops in the routing
    mask = np.eye(n_nodes, dtype=bool)
    # Set diagonal elements to a large negative number to prevent self-loops
    distance_matrix[mask] = -np.inf

    # Calculate the demand difference between nodes
    demand_diff = np.subtract.outer(demands, demands)
    # Set the demand difference for self-loops and zero-demand nodes to -inf
    demand_diff[mask | (demand_diff == 0)] = -np.inf

    # Scale down the demand difference to make it less dominant than distance
    scaled_demand_diff = demand_diff / (capacity + 1e-10)

    # Compute the edge utility: inverse distance to prioritize shorter routes
    # Use a small epsilon to avoid division by zero
    epsilon = 1e-10
    inverse_distance = 1.0 / (distance_matrix + epsilon)

    # Combine inverse distance and scaled demand difference for heuristic values
    heuristic_values = inverse_distance + scaled_demand_diff

    # Penalize edges leading to a node that would exceed the vehicle capacity
    for i in range(n_nodes):
        for j in range(n_nodes):
            if j != 0 and i != 0:  # Exclude the depot
                # Calculate the accumulated demand if customer j is visited after customer i
                accumulated_demand = np.sum(demands[:i]) + demands[j]
                if accumulated_demand > capacity:
                    heuristic_values[i, j] = -np.inf

    return heuristic_values
```
