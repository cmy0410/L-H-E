```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    total_capacity = np.sum(demands)
    normalized_demands = demands / total_capacity

    heuristic_matrix = -np.ones_like(distance_matrix)
    heuristic_matrix[:, 0] = 0
    heuristic_matrix[0, :] = 0
    np.fill_diagonal(heuristic_matrix, 0)

    # Using np.where for vectorized conditional assignment
    heuristic_matrix[np.triu_indices_from(heuristic_matrix, k=1)] = 1 / (distance_matrix[np.triu_indices_from(distance_matrix, k=1)] + 1e-6)

    # Compute the heuristic values for each edge
    combined_demand_matrix = np.outer(normalized_demands, normalized_demands)
    excess_demand_penalty = np.where(combined_demand_matrix > 1, -1000, 0)
    heuristic_matrix -= excess_demand_penalty

    # Adjust heuristic values for edges that are feasible
    feasible_indices = np.where(combined_demand_matrix <= 1)
    heuristic_matrix[feasible_indices] *= (1 - combined_demand_matrix[feasible_indices])

    return heuristic_matrix
```
