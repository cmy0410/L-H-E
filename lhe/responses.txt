Responses:
['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the potential delivery cost at each node (excluding the depot)\n    delivery_cost = distance_matrix[:, 1:] / (1 + demands[1:])\n    \n    # Normalize by the maximum delivery cost to get a value between 0 and 1\n    delivery_cost_normalized = delivery_cost / delivery_cost.max()\n    \n    # Calculate the attractiveness of each edge based on distance and delivery cost\n    edge_attractiveness = 1 / (1 + delivery_cost_normalized) - (distance_matrix / distance_matrix.max())\n    \n    # Set the diagonal (self-loops) to a very negative number to avoid self-loops\n    edge_attractiveness += torch.diag(-torch.inf * torch.ones_like(edge_attractiveness)[0])\n    \n    # Penalize edges where the demand exceeds the capacity\n    over_capacity_penalty = torch.where(demands[None, :] > 1, -torch.inf, 0)\n    edge_attractiveness += over_capacity_penalty\n    \n    # Avoid nan values by setting them to a very negative number\n    edge_attractiveness = torch.nan_to_num(edge_attractiveness, nan=-torch.inf)\n    \n    return edge_attractiveness\n```']['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Calculate the total demand sum\n    total_demand = torch.sum(demands)\n    \n    # Compute the demand ratio for each customer\n    demand_ratio = demands / total_demand\n    \n    # Compute heuristic values based on distance and demand\n    # Reward shorter distances and higher demand nodes\n    # Apply a decay factor to avoid overly high values for low demand nodes\n    heuristic_matrix = (1 / distance_matrix) * demand_ratio[:, None] * demand_ratio[None, :]\n    \n    # Prevent divisions by zero and manage infinity values\n    heuristic_matrix[distance_matrix == 0] = 0\n    heuristic_matrix[torch.isinf(heuristic_matrix)] = 0\n    heuristic_matrix[torch.isnan(heuristic_matrix)] = 0\n    \n    # Apply a penalty for edges that would exceed vehicle capacity\n    # Using a large negative value as a penalty\n    penalty = -1000\n    demand_sums = torch.cumsum(demands, dim=0)\n    for i in range(1, len(demands)):\n        for j in range(i + 1, len(demands)):\n            if demand_sums[j] - demand_sums[i-1] > 1:\n                heuristic_matrix[i, j] = penalty\n                heuristic_matrix[j, i] = penalty\n    \n    # Set heuristic values for the depot to zero or penalty if demand exceeds capacity\n    heuristic_matrix[0, :] = (demands <= 1).float() * heuristic_matrix[0, :]  # Assuming the depot demand is zero or handled separately\n    heuristic_matrix[:, 0] = (demands <= 1).float() * heuristic_matrix[:, 0]\n\n    return heuristic_matrix\n```']['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    capacity = torch.sum(demands)\n    # Calculate the potential gain for each edge based on the savings heuristic\n    savings = distance_matrix[0] * (capacity - demands[1:])\n    savings -= distance_matrix[:, 1:] * demands[1:]\n    \n    # Normalize the savings by the maximum savings to keep values in a reasonable range\n    max_savings = torch.max(savings)\n    savings_normalized = savings / (max_savings + 1e-10)  # prevent division by zero\n    \n    # Make sure no negative values are present for undesirable edges\n    savings_normalized[savings_normalized < 0] = -1e-5\n    \n    # Adjust the diagonal to negative values since no self-loops are allowed\n    torch.fill_diagonal(savings_normalized, -1e-5)\n    \n    return savings_normalized\n```']["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Vehicle capacity is assumed to be 1 since demands are normalized\n    capacity = 1\n    \n    # Compute the demand sum of all pairs of nodes\n    demand_pairs = demands.unsqueeze(0).expand_as(distance_matrix) + demands.unsqueeze(1)\n    \n    # Initialize the heuristic matrix with negative infinity\n    heuristic_matrix = torch.full_like(distance_matrix, float('-inf'))\n    \n    # Set the diagonal (self-loops) to a very negative value\n    heuristic_matrix.fill_diagonal_(-1e9)\n    \n    # Set heuristic values for each edge based on the promise\n    # edges with total demand <= capacity are promising (positive values)\n    heuristic_matrix[distance_matrix < torch.inf] = torch.clamp(\n        (capacity - demand_pairs[distance_matrix < torch.inf]) / (distance_matrix[distance_matrix < torch.inf] + 1e-10),\n        min=0\n    )\n    \n    # Set heuristic values for edges that exceed capacity to a negative value\n    heuristic_matrix[demand_pairs > capacity] = -1e9\n    \n    # Adjust heuristic values to be negative for non-promising edges\n    heuristic_matrix[heuristic_matrix > 0] = -heuristic_matrix[heuristic_matrix > 0]\n    \n    # Ensure that no NaN or inf values are present\n    heuristic_matrix = torch.nan_to_num(heuristic_matrix, nan=-1e9, posinf=-1e9, neginf=-1e9)\n    \n    return heuristic_matrix\n```"]['weights = (1 / (distance_matrix + 1e-10)) ** (1 / 2)```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-10\n\n    # Calculate the service cost which is the inverse of the distance\n    service_cost = 1 / (distance_matrix + epsilon)\n\n    # Calculate the demand penalty which is the inverse of the demand\n    demand_penalty = 1 / (demands.unsqueeze(0).unsqueeze(1) + epsilon)\n\n    # Calculate the heuristic score for each edge\n    # Higher score for shorter distances and lower demand nodes\n    # Ensure that self-loops (distance_matrix[i, i]) are not considered\n    heuristic_scores = service_cost * demand_penalty\n    torch.diagonal(heuristic_scores).zero_()\n\n    # Apply a negative score for edges that exceed the vehicle capacity\n    # Only consider edges from the depot to customers\n    capacity_exceeded = (demands.unsqueeze(0) > demands[0]).float()\n    heuristic_scores[:, 0] -= capacity_exceeded * 1000  # Large negative value\n\n    # Mask edges that would result in capacity overflow\n    for i in range(1, len(demands)):\n        for j in range(1, len(demands)):\n            if demands[i] + demands[j] > demands[0]:\n                heuristic_scores[i, j] = -1000  # Large negative value\n\n    return heuristic_scores\n```']["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the potential load on the vehicle after serving each customer\n    load_after_service = torch.cumsum(demands, dim=0)\n    \n    # Create a mask for edges that exceed the vehicle capacity\n    capacity_mask = (load_after_service[:-1] + demands[1:] <= 1).float()\n    \n    # Calculate the heuristic value for each edge based on distance and capacity\n    # giving higher values to shorter distances and edges that do not exceed capacity\n    heuristic_values = 1 / (distance_matrix + 1e-10) * capacity_mask\n    \n    # Apply negative values for edges that exceed the vehicle capacity\n    heuristic_values[load_after_service[:-1] + demands[1:] > 1] = -torch.inf\n    \n    # Normalize heuristic values to be within a range\n    min_val, max_val = torch.min(heuristic_values), torch.max(heuristic_values)\n    heuristic_values = (heuristic_values - min_val) / (max_val - min_val)\n    \n    # Adjust values to ensure no NaN or Inf, and ensure it's negative for non-promising edges\n    heuristic_values[torch.isinf(heuristic_values)] = -1e10\n    heuristic_values[torch.isnan(heuristic_values)] = -1e10\n    \n    # Set diagonal to a very negative value (no self-loops)\n    torch.diag_(heuristic_values, 0).fill_(-1e10)\n    \n    return heuristic_values\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    capacity = torch.sum(demands)\n    # mask to set the distance from the depot to all nodes and from all nodes to the depot to a very high value\n    depot_mask = torch.tensor([[float('inf')] * len(demands)] + [[float('inf')] + [0] * (len(demands) - 1)] for _ in range(len(demands))])\n    # apply the mask to the distance matrix\n    distance_matrix = torch.where(depot_mask == float('inf'), float('inf'), distance_matrix)\n    # calculate the potential demand after visiting each node\n    potential_demand = torch.cumsum(torch.cat([torch.tensor([0]), demands[:-1]]), dim=0)\n    # calculate the remaining capacity after visiting each node\n    remaining_capacity = capacity - potential_demand\n    # determine the penalty for exceeding the vehicle capacity\n    penalty = (remaining_capacity < 0).float() * (capacity + remaining_capacity.abs())  # penalize over capacity\n    # calculate the heuristic score: inverse distance weighted by the remaining capacity\n    heuristic_scores = 1 / (distance_matrix + 1e-10) * (remaining_capacity.unsqueeze(0).unsqueeze(1) + 1e-10)\n    # apply penalty to the scores where the capacity is exceeded\n    heuristic_scores = torch.where(remaining_capacity < 0, -penalty.unsqueeze(0).unsqueeze(1), heuristic_scores)\n    # mask out the self-loops (visiting the same node)\n    heuristic_scores = torch.where(torch.eye(len(demands)), float('-inf'), heuristic_scores)\n    # mask out the edges from the last node back to the depot\n    heuristic_scores[-1, :] = float('-inf')\n    # mask out the depot to depot edge\n    heuristic_scores[:, 0] = float('-inf')\n    # clip negative values to ensure they are not greater than zero\n    heuristic_scores = torch.clamp(heuristic_scores, min=0)\n    return heuristic_scores\n```"]['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Avoid division by zero and nan values by adding a small epsilon\n    epsilon = 1e-10\n\n    # Calculate the service cost for each edge\n    service_cost = demands[:, None] + demands[None, :] - 2 * demands[None, None]\n\n    # Calculate the heuristic score considering the distance and service cost\n    # Edges with higher service cost and longer distances are less promising\n    # Normalize by the max distance to keep values in a reasonable range\n    max_distance = distance_matrix.max().item()\n    heuristic_scores = 1.0 / (distance_matrix + service_cost + epsilon) / max_distance\n\n    # Penalize edges that exceed vehicle capacity\n    vehicle_capacity = demands.sum().item()\n    capacity_violation = (service_cost > vehicle_capacity).float() * -1000\n\n    # Combine the heuristic scores with the capacity violation penalties\n    heuristic_scores = heuristic_scores + capacity_violation\n\n    # Ensure no negative values for promising edges by clamping\n    heuristic_scores = torch.clamp(heuristic_scores, min=0)\n\n    return heuristic_scores\n```']['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Normalize demands to be between 0 and 1 for the heuristic calculation\n    normalized_demands = demands / torch.max(demands)\n    \n    # Subtract the demand of the customer from the heuristic value to favor lower demand nodes\n    # Add the distance to the heuristic value to penalize longer distances\n    # Exponentially increase the effect of high demands and long distances\n    heuristic_values = torch.exp(-normalized_demands) - torch.exp(distance_matrix)\n    \n    # Set diagonal to a very negative value to prevent self-loops\n    heuristic_values = heuristic_values.scatter_(1, torch.arange(len(heuristic_values)), float(\'-inf\'))\n    \n    # Ensure that no "nan" or "inf" values are produced by clamping\n    heuristic_values = torch.clamp(heuristic_values, min=-float(\'inf\'), max=float(\'inf\'))\n    \n    return heuristic_values\n```']["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Subtract demand pairs if the starting node has enough capacity, else assign negative value\n    demand_diff = torch.outer(demands, demands)\n    heur_matrix = torch.where(\n        demand_diff <= torch.full_like(demand_diff, torch vehicle_capacity),\n        demand_diff,\n        torch.full_like(demand_diff, -float('inf'))\n    )\n    \n    # Subtract the distance for each edge from the demand difference\n    heur_matrix -= distance_matrix\n    \n    # Set the diagonal to a very negative value since no node should be connected to itself\n    torch diagonals = torch.full_like(demands, -float('inf'))\n    torch diagonal_indices = torch.arange(heur_matrix.size(0))\n    heur_matrix[torch diagonal_indices, torch diagonal_indices] = diagonals\n\n    # Set the starting node's self-loop to 0\n    heur_matrix[0, 0] = 0\n\n    # Normalize the heuristic by the maximum value to keep values positive and avoid inf\n    maxheur = torch.max(heur_matrix)\n    heur_matrix = torch.clamp(heur_matrix, min=-float('inf'), max=maxheur)\n    heur_matrix /= maxheur\n\n    return heur_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Avoid division by zero or infinite values\n    demands_safe = torch.clamp(demands, min=1e-6)\n    \n    # Calculate the demand ratio for each edge\n    demand_ratio = (demands_safe[None, :] + demands_safe[:, None]) / (2 * torch.max(demands_safe))\n    \n    # Calculate the heuristic value based on distance and demand ratio\n    # Promising edges have lower distances and higher demand ratio\n    # Negative values for undesirable edges (high cost, low demand ratio)\n    # Positive values for promising edges (low cost, high demand ratio)\n    heuristic_values = (1 / distance_matrix) * (demand_ratio - 1)\n    \n    # Set diagonal to a very negative number since no vehicle can go from a node to itself\n    heuristic_values.fill_diagonal_(-float('inf'))\n    \n    # Ensure no NaNs or Infs are present\n    heuristic_values = torch.nan_to_num(heuristic_values, nan=-float('inf'), posinf=-float('inf'), neginf=-float('inf'))\n    \n    return heuristic_values\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Compute the demand vector for each pair of nodes\n    demand_pairs = demands[:, None] + demands[None, :]\n    \n    # Create a mask where the sum of demands exceeds the vehicle capacity (normalized to 1)\n    over_capacity_mask = (demand_pairs > 1).float()\n    \n    # Assign negative heuristic values for edges that exceed the vehicle capacity\n    heuristic_matrix += -over_capacity_mask * distance_matrix\n    \n    # Calculate the savings for each edge (distance savings if a node is included in the route)\n    savings = distance_matrix - (distance_matrix.sum(dim=1, keepdim=True) + \n                                 distance_matrix.sum(dim=0, keepdim=True) - \n                                 2 * distance_matrix) / 2\n\n    # Normalize the savings by the max savings to keep values in a reasonable range\n    max_savings = savings.max()\n    normalized_savings = savings / max_savings\n    \n    # Assign positive heuristic values based on savings, avoiding self-loops and depot to depot\n    heuristic_matrix += normalized_savings * (1 - torch.eye(distance_matrix.shape[0], dtype=torch.float32))\n    \n    # clip values to avoid nan or inf\n    heuristic_matrix = torch.clamp(heuristic_matrix, min=-float('inf'), max=float('inf'))\n    \n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure no division by zero or infinite values occur\n    demands = torch.clamp(demands, min=1e-6)\n    \n    # Calculate the demand ratio for each edge\n    demand_pairs = demands.unsqueeze(0) + demands.unsqueeze(1)\n    \n    # Calculate the heuristic score based on distance and demand balance\n    # Higher demands and shorter distances are more promising\n    # Score is penalized when demand exceeds vehicle capacity (normalized to 1)\n    score_matrix = (1 / distance_matrix) - (demand_pairs / 2)\n    \n    # Penalize edges with total demand exceeding the vehicle capacity\n    score_matrix[torch.diag_indices(len(score_matrix))] = 0  # No self-loops\n    score_matrix[demand_pairs > 1] = -float('inf')  # Demand exceeds capacity\n    \n    # Make sure the depot does not have negative values as it is always included\n    score_matrix[:, 0] = torch.clamp(score_matrix[:, 0], min=0)\n    score_matrix[0, :] = torch.clamp(score_matrix[0, :], min=0)\n    \n    return score_matrix\n```"]['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the demand sum for each pair of nodes (i, j)\n    demand_pairs = demands[:, None] + demands[None, :]\n    # Subtract the depot demand as it does not contribute to the vehicle load\n    demand_pairs[:, 0] -= demands[0]\n    demand_pairs[0, :] -= demands[0]\n\n    # Initialize the heuristic matrix with the negative distance\n    heuristic_matrix = -distance_matrix\n\n    # Adjust heuristic based on demand pairs relative to vehicle capacity (cap)\n    cap = torch.max(demands)\n    load_diff = torch.clamp((cap - demand_pairs) / cap, 0)  # Only positive differences\n    # Reduce the negative effect of high load edges\n    heuristic_matrix += load_diff * (1 / (distance_matrix + 1e-8))\n\n    # penalize edges leading to overcapacity\n    overcapacity_penalty = (demand_pairs > cap).float() * -1000\n    heuristic_matrix += overcapacity_penalty\n\n    # penalize edges with zero demand (no delivery)\n    zero_demand_penalty = (demand_pairs == 0).float() * -100\n    heuristic_matrix += zero_demand_penalty\n\n    # Ensure no NaN or Inf values in the heuristic matrix\n    heuristic_matrix = torch.nan_to_num(heuristic_matrix, nan=-1000, posinf=-1000, neginf=-1000)\n\n    return heuristic_matrix\n```']["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Constants for the heuristic calculation\n    MAX_DEMAND = torch.max(demands)\n    DEMAND_THRESHOLD = 0.5 * MAX_DEMAND\n    \n    # Create a mask where each element indicates if the demand at node i can be served by a single vehicle trip\n    single_trip_mask = (demands <= DEMAND_THRESHOLD).unsqueeze(0).repeat(len(demands), 1)\n    \n    # Create a heuristic matrix initialized with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Calculate the heuristic values\n    # penalize edges with high distances and high demands\n    heuristic_matrix += (distance_matrix - torch.min(distance_matrix)) / torch.max(distance_matrix)\n    heuristic_matrix += (demands.unsqueeze(0) + demands.unsqueeze(1)) / (2 * MAX_DEMAND)\n    \n    # Apply a penalty to edges where the combined demand exceeds the threshold\n    heuristic_matrix += (single_trip_mask == 0).float() * torch.clamp(\n        (demands.unsqueeze(0) + demands.unsqueeze(1) - DEMAND_THRESHOLD) / MAX_DEMAND, 0, 1\n    ) * torch.max(distance_matrix)\n    \n    # Apply a demand distance factor that adjusts the penalty/reward based on the distance\n    demand_distance_factor = (distance_matrix / torch.max(distance_matrix)) * (MAX_DEMAND - demands.unsqueeze(0))\n    heuristic_matrix -= demand_distance_factor\n    \n    # Penalize edges leading to the depot with high demand nodes\n    heuristic_matrix[:, 0] -= demands.unsqueeze(0) * 0.5\n    \n    # Ensure that no NaN or inf values are introduced\n    heuristic_matrix = torch.nan_to_num(heuristic_matrix)\n    heuristic_matrix = torch.clamp(heuristic_matrix, min=-float('inf'), max=float('inf'))\n    \n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristics matrix with zeros\n    heuristics_matrix = torch.zeros_like(distance_matrix)\n    \n    # The depot demand is set to 0 and should not be considered in the heuristic\n    demands[0] = 0\n    \n    # Compute the cumulative demand up to each node\n    cumulative_demand = torch.cumsum(demands, dim=0)\n    \n    # The heuristic is the inverse of the distance adjusted by the cumulative demand\n    # This promotes shorter distances and considers the load on the vehicle\n    # Avoid division by zero or infinity with clamp and max function\n    demand_factor = torch.clamp(1.0 / cumulative_demand, min=1e-10, max=1.0)\n    \n    # The heuristic value for each edge is the product of the inverse demand factor and the inverse distance\n    # Negative values for the diagonal (self-loops) since they are not valid edges\n    heuristics_matrix = torch.where(distance_matrix == 0, \n                                   torch.full_like(distance_matrix, float('-inf')),\n                                   1.0 / distance_matrix * demand_factor[:, None])\n    \n    # Adjusting for the capacity constraint by reducing the heuristic value\n    # when the demand exceeds the capacity (normalized by capacity)\n    capacity_factor = (cumulative_demand[:, None] / cumulative_demand[-1]).clamp(max=1.0)\n    heuristics_matrix = heuristics_matrix * capacity_factor\n    \n    # Set the heuristic values for edges from the depot to be slightly positive\n    # to encourage starting the route from the depot\n    heuristics_matrix[0, 1:] = torch.clamp(heuristics_matrix[0, 1:], min=0.01)\n    \n    # Return the heuristics matrix, ensuring no NaN or Inf values are present\n    return torch.nan_to_num(heuristics_matrix, nan=-1.0, posinf=-1.0, neginf=-1.0)\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Calculate the Euclidean distance as a base score (inverted to prefer shorter distances)\n    base_score = 1.0 / (distance_matrix + 1e-10)  # Adding a small value to avoid division by zero\n    \n    # Mask the diagonal as these are not valid edges (distance from a node to itself)\n    torch диагональ = torch.eye(distance_matrix.shape[0], device=distance_matrix.device)\n    base_score[diagonal] = -float('inf')\n    \n    # Normalize demands to be between 0 and 1\n    normalized_demands = demands / demands.sum()\n    \n    # Adjust the base score by demand, penalizing edges to high demand nodes\n    # if the demand is too high for a single vehicle trip, heavily penalize\n    score_adjusted_by_demand = base_score - (normalized_demands[:, None] * normalized_demands[None, :])\n    \n    # Further adjust the score by considering the vehicle capacity - discourage high demand pairs\n    # that would exceed the capacity if served by a single vehicle\n    capacity Penalty = 1.0 - (normalized_demands[:, None] + normalized_demands[None, :] <= 1.0).float()\n    score_adjusted_by_capacity = score_adjusted_by_demand * capacity_penalty\n    \n    # Ensure no NaNs or Infs due to the normalization step\n    score_adjusted_by_capacity = torch.nan_to_num(score_adjusted_by_capacity, nan=-float('inf'))\n    score_adjusted_by_capacity = torch.clamp(score_adjusted_by_capacity, min=-float('inf'), max=float('inf'))\n    \n    return score_adjusted_by_capacity\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Compute the total demand for each pair of nodes (i, j)\n    total_demand = demands[:, None] + demands[None, :]\n    \n    # Subtract the demand of the depot node (index 0) from all demands\n    total_demand[:, 0] -= demands[0]\n    total_demand[0, :] -= demands[0]\n    \n    # Calculate a penalty factor for edges based on the remaining capacity\n    # when considering the demands of both nodes connected by the edge\n    remaining_capacity = distance_matrix.new_full((distance_matrix.shape[0], distance_matrix.shape[1]), 1.0)\n    remaining_capacity -= total_demand\n    \n    # Apply a penalty to edges where the combined demand exceeds the capacity (set to -inf)\n    remaining_capacity[remaining_capacity < 0] = float('-inf')\n    \n    # Normalize the heuristic scores by the distance, inverse distance is a common heuristic in CVRP\n    # Positive values for shorter distances, negative or very low for longer or infeasible ones\n    heuristic_matrix = distance_matrix.reciprocal() * remaining_capacity\n    heuristic_matrix[distance_matrix == 0] = 0  # Avoid division by zero for the depot self-loop\n    heuristic_matrix[remaining_capacity == float('-inf')] = float('-inf')\n    \n    # Ensure no NaN values are introduced\n    heuristic_matrix[torch.isnan(heuristic_matrix)] = float('-inf')\n    \n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Ensure that no self-loops are considered (distance from a node to itself)\n    mask = torch.eye(distance_matrix.shape[0], dtype=torch.bool)\n    # Initialize the heuristics matrix with zeros, ignoring self-loops\n    heuristics_matrix = torch.zeros_like(distance_matrix).masked_fill_(mask, float('inf'))\n\n    # Calculate the service cost for each customer, which is the product of demand and distance\n    service_cost = demands[:, None] * distance_matrix\n\n    # Normalize service cost by the maximum service cost to bring values between 0 and 1\n    max_service_cost = torch.max(service_cost)\n    service_cost_normalized = service_cost / max_service_cost\n\n    # Calculate edge utility as the inverse of the normalized service cost\n    # More utility for lower service cost (better edges)\n    edge_utility = 1 / (service_cost_normalized + 1e-10)  # Adding a small constant to avoid division by zero\n\n    # Apply a penalty for edges that would cause overcapacity\n    # Calculate the cumulative demand from the depot to each node\n    cumulative_demand = torchcumsum(torch.cat([torch.zeros(1), demands[:-1]]), dim=0)\n    \n    # Determine if including an edge would exceed the vehicle capacity\n    over_capacity_mask = (cumulative_demand[:, None] + demands[None, 1:] - demands[0]) > 1\n    \n    # Apply a large negative penalty to overcapacity edges\n    edge_utility.masked_fill_(over_capacity_mask, -float('inf'))\n\n    # Replace the infinite values from self-loops with zeros\n    heuristics_matrix = heuristics_matrix.masked_fill_(mask, 0)\n    \n    return heuristics_matrix\n\n# Custom implementation of cumulative sum to avoid using torch's cumulative sum functions\ndef torchcumsum(input_tensor, dim=0):\n    return torch.cat([torch.zeros(input_tensor.shape[0:dim] + (1,)), input_tensor.cumsum(dim)], dim=dim)\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Set diagonal to negative infinity to prevent self-loops\n    torch.fill_diagonal(heuristic_matrix, float('-inf'))\n    \n    # Compute the heuristic values\n    # Subtracting the demands from the capacity to see how much room is left\n    # After this, higher values will mean less capacity left, which is bad, so we negate it\n    capacity_left = 1 - demands\n    \n    # Calculate the potential cost of including an edge considering the remaining capacity\n    # A higher demand node should have a higher penalty when connected to a node with low capacity left\n    # We take the minimum of the two capacity_left values for each edge to represent the 'bottleneck' effect\n    heuristic_matrix += torch.clamp(capacity_left.unsqueeze(0) + capacity_left.unsqueeze(1), 0).neg() * distance_matrix\n\n    # Normalize by the maximum distance to scale the heuristic values\n    heuristic_matrix /= distance_matrix.max()\n\n    # Ensure no NaN or infinite values are present\n    heuristic_matrix = torch.nan_to_num(heuristic_matrix, nan=-float('inf'), posinf=-float('inf'), neginf=-float('inf'))\n\n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Subtracting the distance matrix by the mean distance to scale it\n    mean_distance = torch.mean(distance_matrix[distance_matrix != 0])\n    scaled_distance = distance_matrix - mean_distance\n    \n    # Normalizing demands to get the relative demand at each node\n    normalized_demands = demands / torch.sum(demands)\n    \n    # Creating a heuristic matrix initialized with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Avoiding division by zero and computing the heuristic values\n    # The heuristic value for an edge is inversely proportional to the distance and the demand\n    # The heuristic also decreases with higher demand to prefer lower-demand edges\n    # The matrix diagonal is set to a very negative value to exclude self-loops\n    with torch.no_grad():\n        heuristic_matrix[distance_matrix != 0] = \\\n            (1 / (scaled_distance[distance_matrix != 0] + 1e-10)) * \\\n            (1 / (normalized_demands[distance_matrix != 0][:, None] + 1e-10))\n        \n        # Setting diagonal to a negative value to prevent self-loops\n        torch.diagonal(heuristic_matrix) = -float('inf')\n    \n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n    \n    # Exclude self-loops by setting diagonal elements to a very negative number\n    heuristic_matrix.fill_diagonal_(-float('inf'))\n    \n    # Set the heuristic value for the depot to a high positive value for all nodes\n    heuristic_matrix[:, 0] = torch.tensor([100 / d if d > 0 else float('-inf') for d in demands])\n\n    # Calculate the heuristic score based on distance and demand\n    #惩罚距离越远，奖励需求越小\n    heuristic_scores = 1 / (distance_matrix + 1e-10) - demands[:, None] / demands[0]\n    \n    # Correct the heuristic scores for the depot\n    heuristic_scores[:, 0] = 100 / (demands + 1e-10)\n    \n    # Mask the scores where the demand of the node exceeds the capacity (normalized demand > 1)\n    # These edges are not feasible and hence given a very negative score\n    demand_exceed_mask = (demands[:, None] > 1).float() * -float('inf')\n    heuristic_scores = torch.clamp(heuristic_scores, min=0) - demand_exceed_mask\n\n    # Normalize the heuristic scores to be within a range of -1 to 1\n    min_score, max_score = torch.min(heuristic_scores), torch.max(heuristic_scores)\n    heuristic_scores = (heuristic_scores - min_score) / (max_score - min_score) * 2 - 1\n\n    # Set the heuristic matrix with the calculated scores\n    heuristic_matrix[1:, 1:] = heuristic_scores[1:, 1:]\n\n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Constants for the heuristic calculation\n    max_demand = torch.max(demands)\n    capacity = 1.0  # As demands are normalized by capacity, we assume capacity = 1\n    \n    # Calculate the inverse distance, penalizing large distances\n    # Avoid division by zero by adding a small epsilon\n    epsilon = 1e-10\n    inv_distance = 1 / (distance_matrix + epsilon)\n    \n    # Create a demand difference matrix where we subtract the demand of the starting node ( depot )\n    demand_diff = torch.outer(demands, demands)\n    \n    # Penalize edges that result in demand exceeding capacity\n    # by using a large negative value (here -inf, but ensuring no nans)\n    penalty = torch.where(demand_diff > capacity, torch.tensor(float('-inf')), 0)\n    \n    # Calculate the heuristic value for each edge\n    # The heuristic considers inverse distance and demand compatibility\n    heuristic_values = inv_distance + penalty\n    \n    # Further penalize edges with high demand that are far away\n    # by reducing the heuristic value for these edges\n    demand_distance_product = demand_diff * distance_matrix\n    heuristic_values -= demand_distance_product\n\n    # Ensure that the diagonal (self-loops) are not altered to -inf\n    torch_DIAG_mask = torch.ones_like(distance_matrix).triu(diagonal=-1).tril(diagonal=1)\n    heuristic_values *= torch DIAG_mask\n\n    return heuristic_values\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Vehicle capacity normalized demand at each node\n    normalized_demands = demands / torch.sum(demands)\n    \n    # Initialize the heuristics matrix with zeros\n    heuristics_matrix = torch.zeros_like(distance_matrix)\n    \n    # Mask out the diagonal (self-loops)\n    heuristics_matrix.fill_diagonal_(float('-inf'))\n    \n    # The heuristic considers the potential reduction in the total distance\n    # while taking into account the capacity constraint\n    # Calculate the potential load on each edge\n    potential_load = torch.outer(normalized_demands, normalized_demands)\n    \n    # Adjust load by the distance, rewarding shorter distances with higher loads\n    # Use a soft division to prevent division by zero or Inf values\n    edge_values = potential_load / (distance_matrix + 1e-10)\n    \n    # Mask out edges where the combined demands exceed the capacity (negative heuristic score)\n    capacity_mask = (potential_load > 1.0).to(distance_matrix.dtype)\n    edge_values[capacity_mask] = -edge_values[capacity_mask]\n    \n    # Mask out the edges from the depot to itself and from customers to the depot\n    # as they are not part of the solution paths\n    depot_mask = torch.arange(distance_matrix.shape[0]).repeat(2, 1) == 0\n    edge_values[depot_mask] = float('-inf')\n    \n    heuristics_matrix = edge_values\n\n    return heuristics_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    capacity = torch.sum(demands)\n    demand_diff = demands[:-1] - demands[0]  # Differences from the depot's demand\n    demand_diff = demand_diff.repeat(len(demands), 1).T  # Expand for broadcasting\n    \n    # Calculate desirability based on the distance and demand difference\n    desirability = (capacity - demand_diff) / distance_matrix\n    desirability[desirability < 0] = 0  # Remove negative values as they're not promising\n    desirability[distance_matrix == 0] = -inf  # Depot to depot is not allowed\n    \n    # Normalize to stay away from NaNs and Infs\n    max_val = torch.max(desirability)\n    min_val = torch.min(desirability)\n    if not torch.isfinite(max_val) or not torch.isfinite(min_val):\n        # In case of Inf or NaN values, clip and re-normalize\n        desirability = torch.clamp(desirability, min=-1e9, max=1e9)\n        max_val = torch.max(desirability)\n        min_val = torch.min(desirability)\n    \n    # Normalize to range [0, 1]\n    desirability = (desirability - min_val) / (max_val - min_val)\n    \n    # Adjust for edges leading to exceeding capacity\n    for i in range(1, len(demands)):\n        for j in range(1, len(demands)):\n            if demands[i] + demands[j] > capacity:\n                desirability[i, j] = -inf\n    \n    return desirability\n```"]['```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Compute the Euclidean distance if the distance matrix is not already given\n    # This step is redundant if the distance matrix is already the Euclidean distance\n    # if not already computed, uncomment the following lines:\n    # n = distance_matrix.shape[0]\n    # distance_matrix = torch.cdist(torch.arange(n).float().unsqueeze(0), torch.arange(n).float().unsqueeze(0))\n\n    # Subtract demands vector from a large constant to prevent division by zero\n    demand scaling_factor = 1e4\n    adjusted_demands = scaling_factor - demands\n\n    # Calculate the inverse of the demand for heuristic purposes, smaller demand means higher priority\n    # Cap the inverse demand at a certain value to avoid too high values for nodes with very low demand\n    max_inverse_demand = 10.0\n    inverse_demand = torch.clamp(adjusted_demands / adjusted_demands.max(), max=max_inverse_demand)\n\n    # Compute heuristic scores: inverse demand weighted by the inverse of distance\n    # Score is high for short distances and high inverse demand (low demand nodes)\n    # Avoid division by zero in distance matrix by adding a small constant\n    epsilon = 1e-6\n    scores = inverse_demand[:, None] * inverse_demand[None, :] / (distance_matrix + epsilon)\n\n    # Penalize scores where the total demand exceeds the capacity of a vehicle\n    # Compute the cumulative demand along each row (for each vehicle)\n    cumulative_demand = torch.cumsum(demands, dim=0)\n    # Create a mask where the cumulative demand exceeds the vehicle capacity (normalized to 1)\n    capacity_mask = (cumulative_demand > 1).float()\n    # Apply the penalty by reducing the score\n    scores -= capacity_mask[:, None] * scores.max()\n\n    # Adjust scores to ensure no negative values (as per the requirement)\n    scores = torch.clamp(scores, min=0)\n\n    return scores\n```']["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Constants for the heuristic calculation\n    alpha = 1.0  # Balance between distance and demand\n    beta = 1.0   # Factor to adjust the penalty for capacity violations\n    \n    # Compute the demand difference matrix\n    demands_diff = demands.unsqueeze(0) - demands.unsqueeze(1)\n    \n    # Mask the matrix to set the diagonal to zero (no self-loops) and the depot's demand to zero\n    mask = torch.eye(demands_diff.shape[0], dtype=torch.bool).to(demands_diff.device)\n    demands_diff[mask] = 0\n    \n    # Calculate the heuristic values: distancePenalty - demandPenalty\n    # Demand penalty is high for edges that would cause a capacity violation\n    heuristic_values = (distance_matrix * alpha) - (beta * torch.abs(demands_diff))\n    \n    # Set the heuristic values to negative infinity for pairs that exceed capacity\n    capacity_violations = (demands_diff > 0) & (demands_diff < demands[0])\n    heuristic_values[capacity_violations] = -float('inf')\n    \n    # Ensure that the diagonal (self-loops) are set to a very negative number to discourage them\n    heuristic_values[mask] = -float('inf')\n    \n    # Set the heuristic value for the depot to all nodes to be zero\n    heuristic_values[:, 0] = 0\n    \n    return heuristic_values\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Vehicle capacity is assumed to be 1 since demands are normalized by the total vehicle capacity\n    capacity = 1.0\n    \n    # Copy the distance matrix to avoid modifying the original\n    heuristic_matrix = distance_matrix.clone()\n    \n    # Subtract the demand of each node from the capacity, resulting in the remaining capacity if that node is visited\n    remaining_capacity = capacity - demands\n    \n    # Set diagonal to -inf as self-loops are not allowed (a node can't be connected to itself in this context)\n    torch.put_(heuristic_matrix, torch.arange(len(heuristic_matrix)).repeat(2), float('-inf'))\n    \n    # Make connections to the depot (node 0) promising based on the remaining capacity after serving a node\n    heuristic_matrix[:, 0] += remaining_capacity\n    \n    # Make connections from the depot (node 0) based on the demand of the nodes\n    heuristic_matrix[0, :] -= demands\n    \n    # Adjust the heuristic values by considering the distance, subtracting the remaining capacity\n    # Dividing by the distance gives higher preference to shorter distances, but it is capped by the remaining capacity\n    # Use clamp to ensure that the heuristic values do not become nan or inf\n    heuristic_matrix -= remaining_capacity[:, None] / (heuristic_matrix.clamp(min=1e-10))\n    \n    # Make all negative values more negative to prefer positive values (promising edges)\n    negative_adjustment = torch.min(heuristic_matrix[heuristic_matrix < 0])\n    heuristic_matrix[heuristic_matrix < 0] -= negative_adjustment\n    \n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Initialize the heuristic matrix with zeros\n    heuristic_matrix = torch.zeros_like(distance_matrix)\n\n    # Set diagonal to -inf to discourage self-loops\n    heuristic_matrix.fill_diagonal_(-float('inf'))\n\n    # Set the demand at the depot to 0 as it is the starting point\n    demands[0] = 0\n\n    # Calculate the remaining capacity after each customer demand\n    remaining_capacity = torch.ones_like(demands) * vehicle_capacity - demands\n\n    # Subtract the demands of the destination node from the remaining capacity\n    remaining_capacity -= demands[destination_node]\n\n    # Calculate the heuristic values as a combination of distance and capacity\n    # Avoid division by zero and inf values by clamping the remaining_capacity\n    # to a minimum of 1e-6\n    with torch.no_grad():\n        heuristic_matrix += (1 / (distance_matrix + 1e-6)) * remaining_capacity.view(-1, 1)\n\n    # Adjust heuristic values to be negative for edges exceeding the capacity\n    # and ensure that the values do not become NaN or Inf\n    over_capacity_mask = (demands.view(-1, 1) + demands.view(1, -1) > vehicle_capacity)\n    heuristic_matrix[over_capacity_mask] = -float('inf')\n\n    # clipping the values to avoid extreme positive values which may lead to overflow\n    heuristic_matrix = torch.clamp(heuristic_matrix, min=-float('inf'), max=float('inf'))\n\n    return heuristic_matrix\n```"]["```python\nimport torch\n\ndef heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:\n    # Vehicle capacity is assumed to be 1 since demands are normalized\n    vehicle_capacity = 1.0\n    \n    # Initialize the heuristics matrix with negative infinity to signify non-promising edges\n    heuristics_matrix = torch.full_like(distance_matrix, float('-inf'))\n    \n    # Set the diagonal to a very negative value since no customer should be revisited\n    torch.diag_(heuristics_matrix, 0, 0, -float('inf'))\n\n    # Set the depot to customer edges based on demand and distance\n    for i in range(1, len(demands)):\n        for j in range(1, len(demands)):\n            if demands[i] <= vehicle_capacity:\n                # Promising edge if demand is within capacity and distance is short\n                heuristics_matrix[i, j] = 1 / (distance_matrix[i, j] + 1)  # Adding 1 to avoid division by zero\n    \n    # Adjust heuristics based on remaining capacity after picking up the demand\n    remaining_capacity = vehicle_capacity - demands[1:]  # Exclude the depot\n    for i in range(1, len(demands)):\n        heuristics_matrix[0, i] += remaining_capacity[i] / vehicle_capacity\n    \n    # Adjust heuristics to discourage returning to the depot before all demands are met\n    for i in range(1, len(demands)):\n        for j in range(1, len(demands)):\n            if demands[j] > remaining_capacity[i]:\n                heuristics_matrix[i, j] -= demands[j] / vehicle_capacity\n    \n    return heuristics_matrix\n```"]

