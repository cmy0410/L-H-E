```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    # Normalize demands by the total vehicle capacity to be within [0, 1]
    # Assuming the vehicle capacity is 1 for normalization purposes
    total_capacity = 1
    normalized_demands = demands / total_capacity

    # Initialize the heuristic matrix with negative values for all edges
    heuristic_matrix = -np.ones_like(distance_matrix)

    # Set diagonal to zero as there's no cost or benefit to going to the same node
    np.fill_diagonal(heuristic_matrix, 0)

    # Set the heuristic for edges from the depot to a neutral value since they are mandatory
    heuristic_matrix[:, 0] = 0
    heuristic_matrix[0, :] = 0

    # Calculate inverse distance to avoid division by zero, use a small epsilon for numerical stability
    epsilon = 1e-6
    inv_distance = 1 / (distance_matrix + epsilon)

    # Compute the heuristic values for each edge using vectorized operations
    # Calculate the total demand for each pair of nodes
    total_demand_matrix = np.add.outer(normalized_demands, normalized_demands)

    # Apply a penalty for overcapacity edges
    heuristic_matrix[total_demand_matrix > 1] = -1000

    # The heuristic value is based on the inverse distance and the utility of not exceeding the capacity
    utility = 1 - total_demand_matrix
    heuristic_matrix[total_demand_matrix <= 1] = inv_distance[total_demand_matrix <= 1] * utility[total_demand_matrix <= 1]

    return heuristic_matrix
```
