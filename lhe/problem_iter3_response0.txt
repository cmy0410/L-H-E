```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    capacity = np.sum(demands)
    n_nodes = len(demands)

    # Mask the diagonal as we cannot have self-loops in the routing
    mask = np.eye(n_nodes, dtype=bool)
    distance_matrix[mask] = -np.inf  # Set diagonal elements to -inf

    # Calculate the demand difference matrix
    demand_diff = np.subtract.outer(demands, demands)
    demand_diff[mask | (demand_diff == 0)] = -np.inf  # Set self-loops and zero-demand to -inf

    # Scale the demand differences to be less dominant than distance
    scaled_demand_diff = demand_diff / (capacity + 1e-10)

    # Calculate the inverse distance matrix, avoiding division by zero
    inverse_distance = 1.0 / (distance_matrix + 1e-10)

    # Combine inverse distance and scaled demand difference to get heuristic values
    heuristic_values = inverse_distance + scaled_demand_diff

    # Penalize edges that would result in capacity violations
    accumulated_demand = np.cumsum(demands)
    penalty_mask = (accumulated_demand[:, None] + demands - capacity) > 0
    heuristic_values[penalty_mask] = -np.inf

    # Set heuristic values for returning to the depot to -inf
    heuristic_values[:, 0] = -np.inf

    return heuristic_values
```
