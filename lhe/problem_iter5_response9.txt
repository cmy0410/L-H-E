```python
def heuristics_v2(distance_matrix, demands):
    # Initialize the heuristics matrix with zeros
    heuristics_matrix = np.zeros_like(distance_matrix)
    
    # Small constant to avoid division by zero
    epsilon = 1e-10
    
    # Compute edge utility score: inverse of distance
    edge_utility = 1 / (distance_matrix + epsilon)
    
    # Normalize demands by the max capacity (vehicle capacity)
    vehicle_capacity = np.max(demands)
    normalized_demands = demands / vehicle_capacity
    
    # Update heuristics matrix considering utility and normalized demand
    heuristics_matrix = edge_utility * normalized_demands[:, None] * normalized_demands[None, :]
    
    # Penalize self-loops (diagonal elements)
    np.fill_diagonal(heuristics_matrix, -np.inf)
    
    # Additional penalty for connections to the depot based on demand
    heuristics_matrix[0, 1:] = -(normalized_demands[1:] ** 2)
    heuristics_matrix[1:, 0] = -(normalized_demands[1:] ** 2)
    
    # Penalize edges where the combined demand exceeds vehicle capacity
    overcapacity_mask = (normalized_demands[:, None] + normalized_demands[None, :]) > 1
    heuristics_matrix[overcapacity_mask] = -np.inf
    
    return heuristics_matrix
```
