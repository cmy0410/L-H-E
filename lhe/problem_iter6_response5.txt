```python
import numpy as np

def heuristics_v2(distance_matrix, demands):
    capacity = np.sum(demands)
    n_nodes = len(demands)
    
    # Normalize demands by the total vehicle capacity
    normalized_demands = demands / capacity

    # Initialize the heuristic matrix with negative values for all edges
    heuristic_matrix = -np.ones_like(distance_matrix)

    # No self-loops or loops with zero-demand nodes
    np.fill_diagonal(heuristic_matrix, 0)
    heuristic_matrix[demands == 0] = -np.inf

    # Inverse distance with a small epsilon for numerical stability
    epsilon = 1e-10
    inv_distance = 1 / (distance_matrix + epsilon)

    # Compute the heuristic values for each edge
    for i in range(n_nodes):
        for j in range(n_nodes):
            if i != j and demands[i] > 0:
                # Total demand for the segment from i to j
                total_demand_ij = normalized_demands[i] + normalized_demands[j]

                # Avoid capacity violations
                if total_demand_ij > 1:
                    heuristic_matrix[i, j] = -np.inf
                else:
                    # Calculate the heuristic score based on inverse distance and demand compatibility
                    heuristic_score = inv_distance[i, j] * (1 - total_demand_ij)
                    heuristic_matrix[i, j] = heuristic_score

    # Encourage returning to the depot by setting higher positive values for the depot column
    heuristic_matrix[:, 0] = np.maximum(heuristic_matrix[:, 0], 0)

    return heuristic_matrix
```
