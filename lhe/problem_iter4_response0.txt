```python
import numpy as np

def heuristics_v2(distance_matrix, demands):
    n = len(demands)
    vehicle_capacity = 1.0  # Assuming the vehicle capacity is normalized to 1

    # Normalize demands by the vehicle capacity
    normalized_demands = demands / vehicle_capacity

    # Use an epsilon to avoid division by zero when inverting distances
    epsilon = 1e-10
    # Calculate inverse distance and clip it to avoid very large values
    inverse_distance = 1 / (distance_matrix + epsilon)
    inverse_distance = np.clip(inverse_distance, 0, 1e10)

    # Initialize heuristics matrix with negative infinity for all elements
    heuristics_matrix = np.full_like(distance_matrix, -np.inf)

    # penalize self-loops and depot connections
    np.fill_diagonal(heuristics_matrix, -np.inf)
    heuristics_matrix[:, 0] = heuristics_matrix[0, :] = -np.inf

    # Calculate the combined demand for each pair of nodes
    combined_demands = np.dot(np.ones((n, 1)), normalized_demands) + normalized_demands - vehicle_capacity

    # Penalize edges where combined demand exceeds vehicle capacity
    overcapacity_mask = (combined_demands > 0).astype(int)
    heuristics_matrix -= overcapacity_mask * np.inf

    # Demand satisfaction: 1 if demand can be satisfied by a single vehicle, 0 otherwise
    demand_satisfaction = (normalized_demands <= vehicle_capacity).astype(float)
    demand_satisfaction_matrix = np.outer(demand_satisfaction, demand_satisfaction)

    # Update heuristics matrix by adding inverse distance weighted by demand satisfaction
    heuristics_matrix += inverse_distance * demand_satisfaction_matrix

    return heuristics_matrix
```
