```python
import numpy as np

def heuristics_v2(distance_matrix, demands):
    capacity = np.sum(demands)
    n_nodes = len(demands)

    # Mask the diagonal to prevent self-loops
    mask = np.eye(n_nodes, dtype=bool)
    distance_matrix[mask] = -np.inf

    # Calculate the demand difference matrix and adjust for self-loops and zero-demand nodes
    demand_diff = np.subtract.outer(demands, demands)
    demand_diff[mask | (demand_diff == 0)] = -np.inf

    # Scale down the demand difference
    scaled_demand_diff = demand_diff / (capacity + 1e-10)

    # Compute the inverse distance matrix to avoid division by zero
    epsilon = 1e-10
    inverse_distance = 1.0 / (distance_matrix + epsilon)

    # Combine inverse distance and scaled demand difference for heuristic values
    heuristic_values = inverse_distance + scaled_demand_diff

    # Create a matrix indicating if adding a node exceeds capacity
    accumulated_demand = np.cumsum(demands)
    exceeds_capacity = (accumulated_demand[:, None] + demands - capacity) > 0

    # Penalize edges leading to overcapacity, except for the depot
    heuristic_values[exceeds_capacity & ~mask] = -np.inf

    return heuristic_values
```
