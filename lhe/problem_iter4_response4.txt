```python
import torch

def heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:
    n = len(demands)
    vehicle_capacity = 1
    total_demand = torch.sum(demands)
    
    # Initialize the heuristics matrix with high negative values
    heuristics_matrix = -1000 * torch.ones((n, n))

    # Set diagonal elements to zero (self-loops not considered)
    torch.fill_(heuristics_matrix.diagonal(), 0)

    # Calculate the cumulative demand from the depot to each node
    cumulative_demand = torch.cat([torch.zeros(1), torch.cumsum(demands, dim=0)])

    # Compute the potential overcapacity for each edge
    overcapacity = torch.clamp(cumulative_demand[distance_matrix.nonzero(as_tuple=True)] 
                                - cumulative_demand[:-1][distance_matrix.nonzero(as_tuple=True)] 
                                - demands[distance_matrix.nonzero(as_tuple=True)], 
                                min=0)

    # Adjust heuristics based on overcapacity, heavily penalizing overcapacity
    heuristics_matrix[distance_matrix.nonzero(as_tuple=True)] += overcapacity * 1000

    # Normalize the distance to a penalty, avoiding division by zero
    distance_penalty = torch.clamp(1000 / (distance_matrix + 1e-6), min=0)

    # Subtract the distance penalty from the heuristics matrix
    heuristics_matrix -= distance_penalty

    # Ensure no infinite or NaN values in the final matrix
    heuristics_matrix = torch.nan_to_num(heuristics_matrix, nan=-1000, posinf=-1000, neginf=-1000)

    return heuristics_matrix
```
