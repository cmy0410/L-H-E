```python
import torch

def heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:
    """
    Improved heuristics function for CVRP.
    
    Calculates a promising edge indicator based on:
    1. The distance to the node (shorter is better).
    2. The impact of the demand of the node on the vehicle capacity (lower demand is better).
    3. The total demand so far on the vehicle (lower total demand is better).

    Args:
    - distance_matrix: torch.Tensor of shape (n, n), where n is the number of nodes.
    - demands: torch.Tensor of shape (n,), where n is the number of nodes.

    Returns:
    - torch.Tensor of shape (n, n) with heuristic values.
    """
    # Assuming the first node is the depot and demands are normalized by vehicle capacity
    capacity = demands[0]  # The total vehicle capacity
    depot_idx = 0

    # Create a tensor for the total demand so far, initialized with the depot's demand
    total_demand = demands[torch.new_tensor([depot_idx])]

    # Calculate the load factor for each node relative to the vehicle's capacity
    load_factors = demands / capacity

    # Calculate the heuristic value for each edge, considering the above factors
    heuristic_values = torch.zeros_like(distance_matrix)
    for i in range(1, demands.shape[0]):  # Start from 1 as the depot is node 0
        # Compute the impact of adding this customer to the route
        new_demand = demands[i] + total_demand
        # Compute the new load factor if the demand is added
        new_load_factor = new_demand / capacity

        # Prioritize edges that do not exceed the capacity and do not require backtracking
        if new_load_factor <= 1:
            # Higher negative value for larger distances, encouraging selection of shorter routes
            heuristic_values[i, :i] = -distance_matrix[i, :i] * (1 - new_load_factor)
            # Apply a small positive value for the last node to encourage visiting all nodes
            if i == demands.shape[0] - 1:
                heuristic_values[i, i] += 1e-3
        
        # Update the total demand for the next iteration
        total_demand = new_demand if i < demands.shape[0] - 1 else torch.zeros_like(demands)

    return heuristic_values
```
