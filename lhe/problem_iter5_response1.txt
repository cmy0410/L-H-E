```python
import numpy as np

def heuristics_v2(distance_matrix, demands):
    capacity = np.sum(demands)
    n_nodes = len(demands)
    
    # Mask the diagonal to prevent self-loops
    mask = np.eye(n_nodes, dtype=bool)
    distance_matrix[mask] = np.inf  # Set diagonal to infinity
    
    # Calculate demand differences
    demand_diff = np.subtract.outer(demands, demands)
    demand_diff[mask] = -np.inf  # No self-loops
    demand_diff[mask | (demand_diff == 0)] = -np.inf  # No equal demand loops
    
    # Scale demand differences to be less dominant and avoid division by zero
    scaled_demand_diff = demand_diff / (capacity + 1e-10)
    
    # Compute edge utility using inverse distance
    inverse_distance = 1.0 / (distance_matrix + 1e-10)
    
    # Combine distance and demand factors for heuristic scores
    heuristic_scores = inverse_distance + scaled_demand_diff
    
    # penalize edges leading to capacity violations
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if i != j:
                if demands[i] + demands[j] > capacity:
                    heuristic_scores[i, j] = -np.inf
    
    # Set heuristic values for returning to the depot to -inf
    heuristic_scores[:, 0] = -np.inf
    
    return heuristic_scores
```
