```python
import numpy as np

def heuristics_v2(distance_matrix, demands):
    capacity = np.sum(demands)
    n_nodes = len(demands)
    
    # Mask for self-loops
    self_loop_mask = np.eye(n_nodes, dtype=bool)
    
    # Mask for zero-demand nodes
    zero_demand_mask = demands == 0
    
    # Initialize heuristics matrix with negative infinity for self-loops and zero-demand nodes
    heuristics_matrix = np.where(self_loop_mask | zero_demand_mask[:, None], -np.inf, np.zeros_like(distance_matrix))
    
    # Mask depot connections with negative infinity
    heuristics_matrix[0, 1:] = -np.inf
    heuristics_matrix[1:, 0] = -np.inf
    
    # Compute the inverse distance matrix, adding a small epsilon to avoid division by zero
    epsilon = 1e-10
    inverse_distance = 1.0 / (distance_matrix + epsilon)
    
    # Compute the demand difference matrix and scale by capacity
    demand_diff = np.subtract.outer(demands, demands)
    scaled_demand_diff = demand_diff / (capacity + epsilon)
    
    # Update heuristic values with the inverse distance and scaled demand difference
    heuristics_matrix += inverse_distance + scaled_demand_diff
    
    # Adjust the heuristic values to account for capacity constraints
    for i in range(1, n_nodes):
        for j in range(1, n_nodes):
            if i != j and not zero_demand_mask[i] and not zero_demand_mask[j]:
                # Calculate the cumulative demand up to the current node
                cumulative_demand = np.insert(np.cumsum(demands[:i+1]), 0, 0)
                # Check if adding the current node's demand exceeds the capacity
                if np.any(cumulative_demand + demands[j] > capacity):
                    heuristics_matrix[i, j] = -np.inf
    
    return heuristics_matrix
```
