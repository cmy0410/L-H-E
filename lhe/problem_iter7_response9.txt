```python
import torch

def heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:
    n = demands.shape[0]
    # Normalize demands and capacity
    demands = demands / demands.max()
    capacity = torch.ones(n)

    # Calculate the remaining capacity for each node except the depot
    remaining_capacity = torch.cumprod(capacity[:-1], dim=0) * demands[1:]

    # Create a mask to indicate whether adding the demand of a node would exceed the vehicle capacity
    overflow_mask = (demands[:, None] + demands[None, :] > capacity[None, :]).type(torch.float32)

    # Calculate the potential drop in the heuristic value if the edge is chosen
    cumulative_demands = torch.cumsum(demands, dim=0)
    heuristic_drop = demands[None, :-1] + demands[:, None] - (
        remaining_capacity_after_edge=capacity[None, :] - cumulative_demands[None, :-1])

    # Determine if the edge would increase the capacity violation
    capacity_violation = heuristic_drop > 0

    # Apply the heuristic: negative distance for valid edges, otherwise a large negative value
    heuristic_values = torch.where(
        torch.triu(torch.ones(n, n), diagonal=1).bool(),
        -distance_matrix * (1 - capacity_violation),
        torch.full_like(distance_matrix, float('-inf')))

    # Apply a penalty for returning to the depot (visiting the depot more than once)
    depot_penalty = torch.where(cumulative_demands[-1] < 1e-6,
                                torch.full_like(distance_matrix[-1, :], float('-inf')),
                                -distance_matrix[-1, :])

    heuristic_values = torch.where(torch.eye(n, dtype=torch.bool),
                                  depot_penalty,
                                  heuristic_values)

    return heuristic_values
```
