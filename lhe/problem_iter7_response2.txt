```python
def heuristics_v2(distance_matrix: torch.Tensor, demands: torch.Tensor) -> torch.Tensor:
    """
    Heuristics function for the Capacitated Vehicle Routing Problem (CVRP).
    
    :param distance_matrix: Torch tensor of shape (n, n) representing the distance between each pair of nodes.
    :param demands: Torch tensor of shape (n,) representing the demand of each node, normalized by the total vehicle capacity.
    :return: Torch tensor of shape (n, n) representing the heuristic value for each edge.
    """
    # Ensure the demands tensor is flattened to work with in vectorized operations
    demands_flat = demands.flatten()
    
    # Calculate the maximum demand that can be carried by a single vehicle
    max_capacity = demands_flat.max()
    
    # Create a tensor of zeros like the distance matrix for the heuristic values
    heuristic_values = torch.zeros_like(distance_matrix)
    
    # Compute a mask for nodes that are not the depot (1 for nodes, 0 for the depot)
    nodes_mask = torch.ones_like(demands)
    nodes_mask[0] = 0
    
    # Compute a mask for the depot to avoid double counting when backtracking from the depot
    depot_mask = torch.zeros_like(demands)
    depot_mask[0] = 1
    
    # Initialize current_demand and capacity_left
    current_demand = 0.0
    capacity_left = max_capacity
    
    # Calculate the forward and backward passes for the heuristic values
    # Forward pass: from depot to all other nodes
    for i in range(1, demands.size(0)):
        if demands_flat[i] > 0:
            # Check if adding the current node's demand exceeds capacity
            if current_demand + demands_flat[i] <= capacity_left:
                # If not, add the demand and update the heuristic value
                heuristic_values[0, i] = distance_matrix[0, i] + current_demand
                current_demand += demands_flat[i]
            else:
                # If so, the heuristic value is set to a large number (negative value indicating it's not promising)
                heuristic_values[0, i] = float('-inf')
        else:
            # If the node's demand is zero, it does not contribute to the capacity, but we still need to visit it
            heuristic_values[0, i] = distance_matrix[0, i]
        
        capacity_left -= demands_flat[i]
    
    # Reset current_demand and capacity_left for the backward pass
    current_demand = 0.0
    capacity_left = max_capacity
    
    # Backward pass: from all other nodes to the depot
    for i in range(demands.size(0) - 2, -1, -1):
        if demands_flat[i] > 0:
            # Check if the current node can be visited without exceeding capacity
            if current_demand + demands_flat[i] <= capacity_left:
                # Update the heuristic value considering the current node's demand
                heuristic_values[i, 0] = distance_matrix[i, 0] + current_demand
                current_demand += demands_flat[i]
            else:
                # If adding the current node's demand exceeds capacity, set to a large number
                heuristic_values[i, 0] = float('-inf')
        else:
            # If the node's demand is zero, it does not contribute to the capacity
            heuristic_values[i, 0] = distance_matrix[i, 0]
        
        capacity_left -= demands_flat[i]
    
    # Apply a mask to ensure the depot has a heuristic value of 0 and no negative values for other nodes
    heuristic_values = heuristic_values * nodes_mask + depot_mask
    
    return heuristic_values
```
