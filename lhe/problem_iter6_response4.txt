```python
import numpy as np

def heuristics_v2(distance_matrix: np.ndarray, demands: np.ndarray) -> np.ndarray:
    # Normalize demands by the total vehicle capacity
    capacity = np.sum(demands)
    normalized_demands = demands / capacity

    # Initialize the heuristic matrix with negative values for all edges
    heuristic_matrix = -np.ones_like(distance_matrix)

    # Set the heuristic for edges from the depot to a neutral value since they are mandatory
    heuristic_matrix[:, 0] = 0
    heuristic_matrix[0, :] = 0

    # Set diagonal to zero as there's no cost or benefit to going to the same node
    np.fill_diagonal(heuristic_matrix, 0)

    # Calculate inverse distance to avoid division by zero, use a small epsilon for numerical stability
    epsilon = 1e-6
    inv_distance = 1 / (distance_matrix + epsilon)

    # Compute the heuristic values for each edge using vectorized operations
    # Calculate the total demand for each pair of nodes (i, j)
    total_demand_ij = np.add.outer(normalized_demands, normalized_demands)

    # Create a mask for pairs that exceed the capacity
    over_capacity_mask = total_demand_ij > 1

    # Apply a penalty for overcapacity
    heuristic_matrix[over_capacity_mask] = -1000

    # Calculate utility based on the remaining capacity
    utility = 1 - total_demand_ij

    # The heuristic value is based on the inverse distance and the utility
    heuristic_values = inv_distance * utility

    # Update heuristic matrix with the calculated values for non-overcapacity edges
    heuristic_matrix[~over_capacity_mask & (np.arange(len(demands))[:, None] != np.arange(len(demands)))] = heuristic_values[~over_capacity_mask & (np.arange(len(demands))[:, None] != np.arange(len(demands)))]

    return heuristic_matrix
```
